}
.black-text {
color: black !important;
}
.control-label {
color: black !important;
font-weight: bold;
}
"))
})
}
shinyApp(ui = ui, server = server)
# 🔹 UI
# 🔹 UI
# 🔹 UI
ui <- fluidPage(
titlePanel(tags$strong("Music Recommendation System", style="text-align: center;")),
hr(),
sidebarLayout(
sidebarPanel(
selectizeInput("user", "Select User:",
choices = NULL,  # Start with no choices
multiple = FALSE,
options = list(
placeholder = 'Search for a user...',
create = FALSE,  # Prevent users from creating new options
selectOnTab = TRUE  # Select the user when pressing Tab
)),
actionButton("evaluate", "🔍 Show Recommendations"),
h5('Click on "Show Recommendations" to see the recommendations', class="black-text")
),
mainPanel(
uiOutput("dynamic_css"),
h3("🎧 Recommended Artists",
style="text-align: center; font-size: 36px; font-weight: bold; color: #FFFFFF;"),
uiOutput("recommendations_ui")
)
)
)
# 🔹 Server
server <- function(input, output, session) {
# Reactive expression to hold recommendations
recommendations <- reactiveVal(NULL)
# Create a reactive expression for the user input
selected_user <- reactive({
req(input$user)  # Ensure user is selected
input$user       # Return the selected user
})
# Dynamically update the selectize input choices with users and ensure no selection
observe({
# Update selectize input choices with the user data
updateSelectizeInput(session, "user", choices = rownames(database),
options = list(
placeholder = 'Search for a user...',
create = FALSE,  # Prevent users from creating new options
selectOnTab = TRUE,  # Select the user when pressing Tab
onInitialize = I('function() { this.setValue(""); }')  # Clear any selection at initialization
), server = TRUE)
})
# Observe the button click event to generate recommendations
observeEvent(input$evaluate, {
req(input$user)  # Ensure user is selected
# Generate recommendations for the selected user
recomendations <- predict(svd_model, database[selected_user(), , drop = FALSE], n = 5)
predicted_artists <- as(recomendations, "list")[[1]]
if (length(predicted_artists) == 0) {
recommendations(NULL)  # No recommendations found
} else {
# Filter artist details
recommended_artists <- artists[artists$charid %in% predicted_artists, c("name", "pictureURL", "charid", "url")]
# Ensure recommended_artists has results
if (nrow(recommended_artists) == 0) {
recommendations(NULL)  # No matching artists found
} else {
# For each recommended artist, fetch their top tracks and image URL
top_artist_info <- lapply(recommended_artists$url, scrap_url)
# Add top tracks and background image URL to the data
recommended_artists$top_tracks <- sapply(top_artist_info, function(info){
if (length(info$top_tracks) == 0) {
return("No top tracks found")
}
return(paste(info$top_tracks, collapse = ", "))
})
recommended_artists$img_url <- sapply(top_artist_info, function(info) info$img_url)
recommendations(recommended_artists) # Save the results to the reactive value
}
}
# Render the recommendations UI based on the reactive value
output$recommendations_ui <- renderUI({
rec_artists <- recommendations()
if (is.null(rec_artists)) {
return(h4("❌ No recommendations found!", style="color: #FFFFFF; font-weight: bold;"))
}
# Display recommended artists and their top tracks
lapply(1:nrow(rec_artists), function(i) {
artist <- rec_artists[i, ]
fluidRow(
column(3,
img(src = artist$img_url, height = "200px", style="border-radius:10px; max-width: 100%;")),
column(9,
h4(artist$name, style="font-weight: bold; color: #FFCC00; font-size: 24px;"),
strong("Top Tracks:", class = "top-song"),
tags$ul(lapply(strsplit(artist$top_tracks, ",")[[1]], function(song) {
tags$li(style="color: #FFFFFF; text-align: left; font-size: 16px;", trimws(song))
}))
),
hr()
)
})
})
})
# Apply CSS styles
output$dynamic_css <- renderUI({
tags$style(HTML("
.sidebar {
background-color: #1DB954;
}
body {
background-color: #1DB954;
color: white;
}
.top-song {
color: white;
text-decoration: underline;
text-align: left;
font-size: 18px;
}
.black-text {
color: black !important;
}
.control-label {
color: black !important;
font-weight: bold;
}
"))
})
}
shinyApp(ui = ui, server = server)
# 🔹 UI
ui <- fluidPage(
titlePanel(tags$strong("Music Recommendation System", style="text-align: center;")),
hr(),
sidebarLayout(
sidebarPanel(
selectizeInput("user", "Select User:",
choices = NULL,  # Start with no choices
multiple = FALSE,
options = list(
placeholder = 'Search for a user...',
create = FALSE,  # Prevent users from creating new options
selectOnTab = TRUE,  # Select the user when pressing Tab
onInitialize = I('function() { this.setValue(""); }')  # Clear any selection at initialization
)),
actionButton("evaluate", "🔍 Show Recommendations"),
h5('Click on "Show Recommendations" to see the recommendations', class="black-text")
),
mainPanel(
uiOutput("dynamic_css"),
h3("🎧 Recommended Artists",
style="text-align: center; font-size: 36px; font-weight: bold; color: #FFFFFF;"),
uiOutput("recommendations_ui")
)
)
)
# 🔹 Server
server <- function(input, output, session) {
# Reactive expression to hold recommendations
recommendations <- reactiveVal(NULL)
# Create a reactive expression for the user input
selected_user <- reactive({
req(input$user)  # Ensure user is selected
input$user       # Return the selected user
})
# Dynamically update the selectize input choices with users
observe({
# Update selectize input choices with the user data and ensure no selection
updateSelectizeInput(session, "user", choices = rownames(database),
selected = NULL, # Ensure no initial selection
options = list(
placeholder = 'Search for a user...',
create = FALSE,  # Prevent users from creating new options
selectOnTab = TRUE  # Select the user when pressing Tab
), server = TRUE)
})
# Observe the button click event to generate recommendations
observeEvent(input$evaluate, {
req(input$user)  # Ensure user is selected
# Generate recommendations for the selected user
recomendations <- predict(svd_model, database[selected_user(), , drop = FALSE], n = 5)
predicted_artists <- as(recomendations, "list")[[1]]
if (length(predicted_artists) == 0) {
recommendations(NULL)  # No recommendations found
} else {
# Filter artist details
recommended_artists <- artists[artists$charid %in% predicted_artists, c("name", "pictureURL", "charid", "url")]
# Ensure recommended_artists has results
if (nrow(recommended_artists) == 0) {
recommendations(NULL)  # No matching artists found
} else {
# For each recommended artist, fetch their top tracks and image URL
top_artist_info <- lapply(recommended_artists$url, scrap_url)
# Add top tracks and background image URL to the data
recommended_artists$top_tracks <- sapply(top_artist_info, function(info){
if (length(info$top_tracks) == 0) {
return("No top tracks found")
}
return(paste(info$top_tracks, collapse = ", "))
})
recommended_artists$img_url <- sapply(top_artist_info, function(info) info$img_url)
recommendations(recommended_artists) # Save the results to the reactive value
}
}
# Render the recommendations UI based on the reactive value
output$recommendations_ui <- renderUI({
rec_artists <- recommendations()
if (is.null(rec_artists)) {
return(h4("❌ No recommendations found!", style="color: #FFFFFF; font-weight: bold;"))
}
# Display recommended artists and their top tracks
lapply(1:nrow(rec_artists), function(i) {
artist <- rec_artists[i, ]
fluidRow(
column(3,
img(src = artist$img_url, height = "200px", style="border-radius:10px; max-width: 100%;")),
column(9,
h4(artist$name, style="font-weight: bold; color: #FFCC00; font-size: 24px;"),
strong("Top Tracks:", class = "top-song"),
tags$ul(lapply(strsplit(artist$top_tracks, ",")[[1]], function(song) {
tags$li(style="color: #FFFFFF; text-align: left; font-size: 16px;", trimws(song))
}))
),
hr()
)
})
})
})
# Apply CSS styles
output$dynamic_css <- renderUI({
tags$style(HTML("
.sidebar {
background-color: #1DB954;
}
body {
background-color: #1DB954;
color: white;
}
.top-song {
color: white;
text-decoration: underline;
text-align: left;
font-size: 18px;
}
.black-text {
color: black !important;
}
.control-label {
color: black !important;
font-weight: bold;
}
"))
})
}
shinyApp(ui = ui, server = server)
# 🔹 UI
# 🔹 UI
ui <- fluidPage(
titlePanel(tags$strong("Music Recommendation System", style="text-align: center;")),
hr(),
sidebarLayout(
sidebarPanel(
selectizeInput("user", "Select User:",
choices = NULL,  # Start with no choices
multiple = FALSE,
selected = NULL,  # Make sure there's no default selection
options = list(
placeholder = 'Search for a user...',
create = FALSE,  # Prevent users from creating new options
selectOnTab = TRUE,  # Select the user when pressing Tab
onInitialize = I('function() { this.setValue(""); }')  # Clear any selection at initialization
)),
actionButton("evaluate", "🔍 Show Recommendations"),
h5('Click on "Show Recommendations" to see the recommendations', class="black-text")
),
mainPanel(
uiOutput("dynamic_css"),
h3("🎧 Recommended Artists",
style="text-align: center; font-size: 36px; font-weight: bold; color: #FFFFFF;"),
uiOutput("recommendations_ui")
)
)
)
# 🔹 Server
server <- function(input, output, session) {
# Reactive expression to hold recommendations
recommendations <- reactiveVal(NULL)
# Create a reactive expression for the user input
selected_user <- reactive({
req(input$user)  # Ensure user is selected
input$user       # Return the selected user
})
# Dynamically update the selectize input choices with users
observe({
# Update selectize input choices with the user data
updateSelectizeInput(session, "user", choices = rownames(database),
selected = NULL, # Ensure no initial selection
options = list(
placeholder = 'Search for a user...',
create = FALSE,  # Prevent users from creating new options
selectOnTab = TRUE  # Select the user when pressing Tab
), server = TRUE)
})
# Observe the button click event to generate recommendations
observeEvent(input$evaluate, {
req(input$user)  # Ensure user is selected
# Generate recommendations for the selected user
recomendations <- predict(svd_model, database[selected_user(), , drop = FALSE], n = 5)
predicted_artists <- as(recomendations, "list")[[1]]
if (length(predicted_artists) == 0) {
recommendations(NULL)  # No recommendations found
} else {
# Filter artist details
recommended_artists <- artists[artists$charid %in% predicted_artists, c("name", "pictureURL", "charid", "url")]
# Ensure recommended_artists has results
if (nrow(recommended_artists) == 0) {
recommendations(NULL)  # No matching artists found
} else {
# For each recommended artist, fetch their top tracks and image URL
top_artist_info <- lapply(recommended_artists$url, scrap_url)
# Add top tracks and background image URL to the data
recommended_artists$top_tracks <- sapply(top_artist_info, function(info){
if (length(info$top_tracks) == 0) {
return("No top tracks found")
}
return(paste(info$top_tracks, collapse = ", "))
})
recommended_artists$img_url <- sapply(top_artist_info, function(info) info$img_url)
recommendations(recommended_artists) # Save the results to the reactive value
}
}
# Render the recommendations UI based on the reactive value
output$recommendations_ui <- renderUI({
rec_artists <- recommendations()
if (is.null(rec_artists)) {
return(h4("❌ No recommendations found!", style="color: #FFFFFF; font-weight: bold;"))
}
# Display recommended artists and their top tracks
lapply(1:nrow(rec_artists), function(i) {
artist <- rec_artists[i, ]
fluidRow(
column(3,
img(src = artist$img_url, height = "200px", style="border-radius:10px; max-width: 100%;")),
column(9,
h4(artist$name, style="font-weight: bold; color: #FFCC00; font-size: 24px;"),
strong("Top Tracks:", class = "top-song"),
tags$ul(lapply(strsplit(artist$top_tracks, ",")[[1]], function(song) {
tags$li(style="color: #FFFFFF; text-align: left; font-size: 16px;", trimws(song))
}))
),
hr()
)
})
})
})
# Apply CSS styles
output$dynamic_css <- renderUI({
tags$style(HTML("
.sidebar {
background-color: #1DB954;
}
body {
background-color: #1DB954;
color: white;
}
.top-song {
color: white;
text-decoration: underline;
text-align: left;
font-size: 18px;
}
.black-text {
color: black !important;
}
.control-label {
color: black !important;
font-weight: bold;
}
"))
})
}
shinyApp(ui = ui, server = server)
ui <- fluidPage(
titlePanel(tags$strong("Music Recommendation System", style="text-align: center;")),
hr(),
sidebarLayout(
sidebarPanel(
selectizeInput("user", "Select User:", choices = rownames(r), multiple = FALSE, options = list(
placeholder = 'Search for a user...',
maxOptions = 100,  # Increase the number of displayed options
create = FALSE,  # Prevent users from creating new options
persist = FALSE  # Prevent persisting values not in the list
)),
actionButton("evaluate", "🔍 Show Recommendations"),
h5('Click on "Show Recommendations" to see the recommendations', class="black-text")
),
mainPanel(
uiOutput("dynamic_css"),
h3("🎧 Recommended Artists",
style="text-align: center; font-size: 36px; font-weight: bold; color: #FFFFFF;"),
uiOutput("recommendations_ui")
)
)
)
# 🔹 Serveur
server <- function(input, output, session) {
# Reactive expression to hold recommendations
recommendations <- reactiveVal(NULL)
# Create a reactive expression for the user input
selected_user <- reactive({
req(input$user)  # Ensure user is selected
input$user       # Return the selected user
})
# Observe the button click event to generate recommendations
observeEvent(input$evaluate, {
req(input$user)  # Ensure user is selected
#cat("user: ",input$user, "\n")
# Generate recommendations for the selected user
recomendations <- predict(svd_model, database[selected_user(), , drop = FALSE], n = 5)
predicted_artists <- as(recomendations, "list")[[1]]
#cat("predict: ",predicted_artists, "\n")
if (length(predicted_artists) == 0) {
recommendations(NULL)  # No recommendations found
} else {
# Filter artist details
recommended_artists <- artists[artists$charid %in% predicted_artists, c("name", "pictureURL", "charid", "url")]
# Ensure recommended_artists has results
if (nrow(recommended_artists) == 0) {
recommendations(NULL)  # No matching artists found
} else {
# For each recommended artist, fetch their top tracks and image URL
top_artist_info <- lapply(recommended_artists$url, scrap_url)
# Add top tracks and background image URL to the data
recommended_artists$top_tracks <- sapply(top_artist_info, function(info){
# Flatten the list of top tracks to a single character vector
if (length(info$top_tracks) == 0) {
return("No top tracks found")
}
return(paste(info$top_tracks, collapse = ", "))
})
recommended_artists$img_url <- sapply(top_artist_info, function(info) info$img_url)
recommendations(recommended_artists) # Save the results to the reactive value
#print(recommended_artists$name)
}
}
# Render the recommendations UI based on the reactive value
output$recommendations_ui <- renderUI({
rec_artists <- recommendations()
#print(rec_artists$name)
# Check if recommendations exist
if (is.null(rec_artists)) {
return(h4("❌ No recommendations found!", style="color: #FFFFFF; font-weight: bold;"))
}
# Display recommended artists and their top tracks
lapply(1:nrow(rec_artists), function(i) {
artist <- rec_artists[i, ]
fluidRow(
column(3,
img(src = artist$img_url, height = "200px", style="border-radius:10px; max-width: 100%;")),
#cat("img: ",artist$img_url, "\n"),
column(9,
h4(artist$name, style="font-weight: bold; color: #FFCC00; font-size: 24px;"),
#cat("name: ",artist$name, "\n"),
#cat("traks: "),
#print(artist$top_tracks),
strong("Top Tracks:", class = "top-song"),
tags$ul(lapply(strsplit(artist$top_tracks, ",")[[1]], function(song) {
tags$li(style="color: #FFFFFF; text-align: left; font-size: 16px;", trimws(song))
}))
),
hr()
)
})
})
})
# Apply CSS styles
output$dynamic_css <- renderUI({
tags$style(HTML("
.sidebar {
background-color: #1DB954;
}
body {
background-color: #1DB954;
color: white;
}
.top-song {
color: white;
text-decoration: underline;
text-align: left;
font-size: 18px;
}
.black-text {
color: black !important;
}
.control-label {
color: black !important;
font-weight: bold;
}
"))
})
}
shinyApp(ui = ui, server = server)
View(user_artists_wide)
View(artists)
