Recommender(train, method = "POPULAR"),
Recommender(train, method = "IBCF"),
Recommender(train, method = "UBCF"),
weights = c(0.70, 0.20, 0.10)
)
hybrid_p <- predict(hybrid_r, test, type = "ratings")####################################
# Hybrid + cascade aproach of Popular, IBCF and UBCF + UBCF
hcas_r <- (0.35 * as(p_p, "matrix") + 0.35 * as(ib_p, "matrix") + 0.3 * as(ub_p, "matrix") )
hcas_r_rrm <- as(hcas_r, "realRatingMatrix")
# check best recommender errors
error <- rbind(
POPULAR = calcPredictionAccuracy(p_p, getData(e, "unknown")),
ib = calcPredictionAccuracy(ib_p, getData(e, "unknown")),
ub = calcPredictionAccuracy(ub_p, getData(e, "unknown")),
svd = calcPredictionAccuracy(svd_p, getData(e, "unknown")),
hybrid = calcPredictionAccuracy(hybrid_p, getData(e, "unknown")),
hcas = calcPredictionAccuracy(hcas_p, getData(e, "unknown")),
CASCADE = calcPredictionAccuracy(cascade_p, getData(e, "unknown"))
)
error
# Create a hybrid recommender
hybrid_r <- HybridRecommender(
Recommender(train, method = "POPULAR"),
Recommender(train, method = "IBCF"),
Recommender(train, method = "UBCF"),
weights = c(0.60, 0.30, 0.10)
)
hybrid_p <- predict(hybrid_r, test, type = "ratings")####################################
# Hybrid + cascade aproach of Popular, IBCF and UBCF + UBCF
hcas_r <- (0.35 * as(p_p, "matrix") + 0.35 * as(ib_p, "matrix") + 0.3 * as(ub_p, "matrix") )
# check best recommender errors
error <- rbind(
POPULAR = calcPredictionAccuracy(p_p, getData(e, "unknown")),
ib = calcPredictionAccuracy(ib_p, getData(e, "unknown")),
ub = calcPredictionAccuracy(ub_p, getData(e, "unknown")),
svd = calcPredictionAccuracy(svd_p, getData(e, "unknown")),
hybrid = calcPredictionAccuracy(hybrid_p, getData(e, "unknown")),
hcas = calcPredictionAccuracy(hcas_p, getData(e, "unknown")),
CASCADE = calcPredictionAccuracy(cascade_p, getData(e, "unknown"))
)
error
# Create a hybrid recommender
hybrid_r <- HybridRecommender(
Recommender(train, method = "POPULAR"),
Recommender(train, method = "IBCF"),
Recommender(train, method = "UBCF"),
weights = c(0.65, 0.25, 0.10)
)
hybrid_p <- predict(hybrid_r, test, type = "ratings")####################################
# check best recommender errors
error <- rbind(
POPULAR = calcPredictionAccuracy(p_p, getData(e, "unknown")),
ib = calcPredictionAccuracy(ib_p, getData(e, "unknown")),
ub = calcPredictionAccuracy(ub_p, getData(e, "unknown")),
svd = calcPredictionAccuracy(svd_p, getData(e, "unknown")),
hybrid = calcPredictionAccuracy(hybrid_p, getData(e, "unknown")),
hcas = calcPredictionAccuracy(hcas_p, getData(e, "unknown")),
CASCADE = calcPredictionAccuracy(cascade_p, getData(e, "unknown"))
)
error
hcas_p <- Recommender(hcas_r_rrm, method="UBCF", param=list(nn=50))
hcas_p <- predict(hcas_p, test, type="ratings")
# check best recommender errors
error <- rbind(
POPULAR = calcPredictionAccuracy(p_p, getData(e, "unknown")),
ib = calcPredictionAccuracy(ib_p, getData(e, "unknown")),
ub = calcPredictionAccuracy(ub_p, getData(e, "unknown")),
svd = calcPredictionAccuracy(svd_p, getData(e, "unknown")),
hybrid = calcPredictionAccuracy(hybrid_p, getData(e, "unknown")),
hcas = calcPredictionAccuracy(hcas_p, getData(e, "unknown")),
CASCADE = calcPredictionAccuracy(cascade_p, getData(e, "unknown"))
)
error
hcas_p <- Recommender(hcas_r_rrm, method="UBCF", param=list(nn=50, normalize="center"))
hcas_p <- predict(hcas_p, test, type="ratings")
# check best recommender errors
error <- rbind(
POPULAR = calcPredictionAccuracy(p_p, getData(e, "unknown")),
ib = calcPredictionAccuracy(ib_p, getData(e, "unknown")),
ub = calcPredictionAccuracy(ub_p, getData(e, "unknown")),
svd = calcPredictionAccuracy(svd_p, getData(e, "unknown")),
hybrid = calcPredictionAccuracy(hybrid_p, getData(e, "unknown")),
hcas = calcPredictionAccuracy(hcas_p, getData(e, "unknown")),
CASCADE = calcPredictionAccuracy(cascade_p, getData(e, "unknown"))
)
error
library(shiny)
library(tidyr)
library(recommenderlab)
## Load Data
artists = read.table("Data/artists_gp4.dat",sep="\t",stringsAsFactors = F,comment.char = "",quote="",header = T)
user_artists = read.table("Data/user_artists_gp4.dat",sep="\t",header = T)
### Data Transformation
#Let's convert to wider format such that each row represent the listened count of a user.
user_artists_wide <- spread(user_artists,key=artistID,value=weight)
dim(user_artists_wide)
## Create character Id
artists$charid=paste0("I",artists$id)
userids=user_artists_wide$userID
user_artists_wide$IuserID = NULL
rownames(user_artists_wide) = paste0("U",userids)
colnames(user_artists_wide) = paste0("I",colnames(user_artists_wide))
user_artists_wide[1:6,1:10]
# Select Top 1000
visits_byitem=colSums(user_artists_wide[,-1],na.rm = T)
visits_1k = user_artists_wide[,order(visits_byitem,decreasing = T)[1:1000]]
# Select users who has listened to at least 10 artists
num_visits=apply(visits_1k,1,function(x) return(sum(!is.na(x))))
visits_1k = visits_1k[num_visits>10,]
dim(visits_1k)
# Data is centered and scaled
visits_1k=t(scale(t(visits_1k))[,])
# Convert visits_1k into a recommanderlab sparse matrix
visits_1k_rrm=as(as.matrix(visits_1k),"realRatingMatrix")
set.seed(100)
# The matrix is converted into a realRatingMatrix object which stores the data in sparse format
# (only non-NA values are stored explicitly; NA values are represented by a dot)
r <- visits_1k_rrm
# Understand the data better
as(r[1,], "list")
rowMeans(r[1,])
hist(getRatings(r), breaks=60)
hist(rowCounts(r), breaks=50)
hist(colMeans(r), breaks=20)
# The rating matrix can converted into a data.frame with user/item/rating tuples.
head(as(r, "data.frame"))
################################################################################
# here we have all the different methods
recommenderRegistry$get_entries(dataType = "realRatingMatrix")
# We create recommenders which generates recommendations of songs
p_rr <- Recommender(r[1:700], method = "POPULAR")
ib_rr <- Recommender(r[1:700], method = "IBCF")
# Recommendations in the form of an object of class TopNList
# We create top-5 recommendation lists for 88 users who were not used to learn the model.
recom <- predict(p_rr, r[700:788], n=5)
recom
recom@items
recom@ratings
# The result contains two ordered top-N recommendation lists, one for each user.
# The recommended items can be inspected as a list
Myrecommendations<-as(recom, "list")
for (i in 1:5){
print(Myrecommendations[i])
print(artists$name[artists$charid %in% Myrecommendations[[i]]])
}
# The best 3 recommendations for each list using bestN().
recom3 <- bestN(recom, n = 3)
recom3
Myrecommendations3<-as(recom3, "list")
for (i in 1:3){
print(Myrecommendations3[i])
print(artists$name[artists$charid %in% Myrecommendations3[[i]]])
}
### Evaluation of predicted ratings
# Evaluation of a top-N recommender algorithm
set.seed(100)
e <- evaluationScheme(r, method="cross", k=4, given=10, goodRating=1.2)
train=getData(e, "train")
test=getData(e, "known")
ub_r <- Recommender(train, method="UBCF", param=list(nn=50, normalize="center"))
p_r <- Recommender(train, method="POPULAR")
ib_r <- Recommender(train, method="IBCF", param=list(k=50, method="cosine", normalize="center"))
svd_r <- Recommender(train, method="SVD")
# Compute predicted ratings for the known part of the test data  (10 items for each
# user) using the algorithms.
p_p <- predict(p_r, test, type="ratings")
ib_p <- predict(ib_r, test, type="ratings")
ub_p <- predict(ub_r, test, type="ratings")
svd_p <- predict(svd_r, test, type = "ratings")
# Create a hybrid recommender
hybrid_r <- HybridRecommender(
Recommender(train, method = "POPULAR"),
Recommender(train, method = "IBCF"),
Recommender(train, method = "UBCF"),
weights = c(0.65, 0.25, 0.10)
)
hybrid_p <- predict(hybrid_r, test, type = "ratings")
# Hybrid + cascade aproach of Popular, IBCF and UBCF + UBCF
hcas_r <- (0.35 * as(p_p, "matrix") + 0.35 * as(ib_p, "matrix") + 0.3 * as(ub_p, "matrix") )
hcas_r_rrm <- as(hcas_r, "realRatingMatrix")
hcas_p <- Recommender(hcas_r_rrm, method="UBCF", param=list(nn=50))
hcas_p <- predict(hcas_p, test, type="ratings")
# Evaluating cascade UBCF and then IBCF on top of the UBCF
cascade_r_rrm <- as(as(p_p, "matrix"), "realRatingMatrix")
cascade_r <- Recommender(cascade_r_rrm, method="UBCF",param=list(nn=50, normalize="center"))
cascade_p <- predict(cascade_r, test, type="ratings")
# check best recommender errors
error <- rbind(
POPULAR = calcPredictionAccuracy(p_p, getData(e, "unknown")),
ib = calcPredictionAccuracy(ib_p, getData(e, "unknown")),
ub = calcPredictionAccuracy(ub_p, getData(e, "unknown")),
svd = calcPredictionAccuracy(svd_p, getData(e, "unknown")),
hybrid = calcPredictionAccuracy(hybrid_p, getData(e, "unknown")),
hcas = calcPredictionAccuracy(hcas_p, getData(e, "unknown")),
CASCADE = calcPredictionAccuracy(cascade_p, getData(e, "unknown"))
)
error
# check best topNList
p_p_top <- predict(p_r, test, type = "topNList", n = 5)
ib_p_top <- predict(ib_r, test, type = "topNList", n = 5)
ub_p_top <- predict(ub_r, test, type = "topNList", n = 5)
svd_p_top <- predict(svd_r, test, type = "topNList", n = 5)
hybrid_p_top <- predict(hybrid_r, test, type = "topNList", n = 5)
hcas_p_top <- predict(hcas_r, test, type = "topNList", n = 5)
# Hybrid + cascade aproach of Popular, IBCF and UBCF + UBCF
hcas <- (0.35 * as(p_p, "matrix") + 0.35 * as(ib_p, "matrix") + 0.3 * as(ub_p, "matrix") )
hcas_rrm <- as(hcas, "realRatingMatrix")
hcas_r <- Recommender(hcas_rrm, method="UBCF", param=list(nn=50))
hcas_p <- predict(hcas_p, test, type="ratings")
# Hybrid + cascade aproach of Popular, IBCF and UBCF + UBCF
hcas <- (0.35 * as(p_p, "matrix") + 0.35 * as(ib_p, "matrix") + 0.3 * as(ub_p, "matrix") )
hcas_rrm <- as(hcas, "realRatingMatrix")
hcas_r <- Recommender(hcas_rrm, method="UBCF", param=list(nn=50))
hcas_p <- predict(hcas_p, test, type="ratings")
hcas_p <- predict(hcas_r, test, type="ratings")
# check best topNList
p_p_top <- predict(p_r, test, type = "topNList", n = 5)
ib_p_top <- predict(ib_r, test, type = "topNList", n = 5)
ub_p_top <- predict(ub_r, test, type = "topNList", n = 5)
svd_p_top <- predict(svd_r, test, type = "topNList", n = 5)
hybrid_p_top <- predict(hybrid_r, test, type = "topNList", n = 5)
hcas_p_top <- predict(hcas_r, test, type = "topNList", n = 5)
cascade_p_top <- predict(cascade_r, test, type = "topNList", n = 5)
par(mfrow = c(2, 6))
# Popular
avg(p_results)
plot(p_results, annotate=TRUE)
plot(p_results, "prec/rec", annotate=TRUE)
par(mfrow = c(2, 6))
# Popular
avg(p_results)
# check best topNList
p_p_top <- predict(p_r, test, type = "topNList", n = 5)
avg(p_p_top)
#confusion matrices
getConfusionMatrix(p_p_top)[[1]]  # For Popular
getConfusionMatrix(ib_p_top)[[1]] # For IBCF
?getConfusionMatrix
getResults(p_p_top)
?evaluate
?evaluate
## evaluate several algorithms (including a hybrid recommender) with a list
algorithms <- list(
POPULAR = list(name = "POPULAR", param = NULL),
HYBRID = list(name = "HYBRID", param =
list(recommenders = list(
IBCF = list(name = "IBCF", param = NULL),
POPULAR = list(name = "POPULAR", param = NULL),
IBCF = list(name = "UBCF", param = NULL)
)
)
)
)
evlist <- evaluate(es, algorithms, n=c(1,3,5,10))
evlist <- evaluate(e, algorithms, n=c(1,3,5,10))
evlist
avg(evlist)
plot(evlist)
plot(evlist)
plot(evlist)
plot(evlist)
plot(evlist)
(evlist)
(evlist)
## evaluate several algorithms (including a hybrid recommender) with a list
algorithms <- list(
POPULAR = list(name = "POPULAR", param = NULL),
HYBRID = list(name = "HYBRID", param = list(
recommenders = list(
IBCF = list(name = "IBCF", param = NULL),
POPULAR = list(name = "POPULAR", param = NULL),
UBCF = list(name = "UBCF", param = NULL)
),
weights = c(0.35, 0.35, 0.3)
)),
IBCF = list(name = "IBCF", param = NULL),
UBCF = list(name = "UBCF", param = NULL),
SVD = list(name = "SVD", param = NULL),
HCAS = list(name = "HCAS", param = NULL),
CASCADE = list(name = "CASCADE", param = NULL)
)
evlist <- evaluate(e, algorithms, n=c(1,3,5,10,15,20))
plot(evlist, "roc", annotate="TRUE")
plot(evlist, "ROC", annotate="TRUE")
plot(evlist, "ROC", annotate="TRUE")
png("roc_plot.png", width = 1200, height = 800)
plot(evlist, "roc", annotate = TRUE)
png("roc_plot.png", width = 100, height = 200)
plot(evlist, "roc", annotate = TRUE)
plot(evlist, "ROC", annotate = TRUE)
png("roc_plot.png", width = 300, height = 400)
plot(evlist, "ROC", annotate = TRUE)
png("roc_plot.png", width = 700, height = 800)
plot(evlist, "ROC", annotate = TRUE)
png("roc_plot.png", width = 700, height = 800)
plot(evlist, "ROC", annotate = TRUE)
plot(evlist, "ROC", annotate = TRUE)
png("roc_plot.png", width = 1000, height = 900)
plot(evlist, "ROC", annotate = TRUE)
evlist <- evaluate(e, algorithms, n=c(1,3,5,10,15,20))
png("roc_plot.png", width = 1200, height = 800)
plot(evlist, "ROC", annotate = TRUE)
plot(evlist, "ROC", annotate = TRUE)
evlist <- evaluate(e, algorithms, n=c(1,3,5,10,15,20))
plot(evlist, "ROC", annotate = TRUE)
plot(evlist, "ROC", annotate = TRUE)
plot(evlist, "ROC", annotate = TRUE)
plot(evlist, annotate = TRUE)
## evaluate several algorithms (including a hybrid recommender) with a list
algorithms <- list(
POPULAR = list(name = "POPULAR", param = NULL),
HYBRID = list(name = "HYBRID", param = list(
recommenders = list(
IBCF = list(name = "IBCF", param = NULL),
POPULAR = list(name = "POPULAR", param = NULL),
UBCF = list(name = "UBCF", param = NULL)
),
weights = c(0.35, 0.35, 0.3)
)),
IBCF = list(name = "IBCF", param = NULL),
UBCF = list(name = "UBCF", param = NULL),
SVD = list(name = "SVD", param = NULL),
HCAS = list(name = "HCAS", param = NULL),
CASCADE = list(name = "CASCADE", param = NULL)
)
evlist <- evaluate(e, algorithms, n=c(1,3,5,10,15,20))
plot(evlist, annotate = TRUE)
## evaluate several algorithms (including a hybrid recommender) with a list
algorithms <- list(
POPULAR = list(name = "POPULAR", param = NULL),
HYBRID = list(name = "HYBRID", param = list(
recommenders = list(
IBCF = list(name = "IBCF", param = NULL),
POPULAR = list(name = "POPULAR", param = NULL),
UBCF = list(name = "UBCF", param = NULL)
),
weights = c(0.35, 0.35, 0.3)
)),
IBCF = list(name = "IBCF", param = NULL),
UBCF = list(name = "UBCF", param = NULL),
SVD = list(name = "SVD", param = NULL),
HCAS = list(name = hcas_p, param = NULL),
CASCADE = list(name = cascade_p, param = NULL)
)
evlist <- evaluate(e, algorithms, n=c(1,3,5,10,15,20))
p_p_matrix <- as(p_p_top, "matrix")
p_p_matrix
getConfusionMatrix(p_p_top)[[1]]
# check best recommender errors
error <- rbind(
POPULAR = calcPredictionAccuracy(p_p, getData(e, "unknown")),
ib = calcPredictionAccuracy(ib_p, getData(e, "unknown")),
ub = calcPredictionAccuracy(ub_p, getData(e, "unknown")),
svd = calcPredictionAccuracy(svd_p, getData(e, "unknown")),
hybrid = calcPredictionAccuracy(hybrid_p, getData(e, "unknown")),
hcas = calcPredictionAccuracy(hcas_p, getData(e, "unknown")),
CASCADE = calcPredictionAccuracy(cascade_p, getData(e, "unknown"))
)
error
algorithms <- list(
POPULAR = list(name = "POPULAR", param = NULL),
IBCF = list(name = "IBCF", param = NULL),
UBCF = list(name = "UBCF", param = NULL),
SVD = list(name = "SVD", param = NULL),
HYBRID = list(name = "HYBRID", param = list(
recommenders = list(
IBCF = list(name = "IBCF", param = NULL),
POPULAR = list(name = "POPULAR", param = NULL),
UBCF = list(name = "UBCF", param = NULL)
),
weights = c(0.35, 0.35, 0.3)
))
)
ev <- evaluate(e, algorithms, n = c(1, 3, 5, 10, 15, 20))
plot(ev)
plot(ev, "prec/rec", annotate = TRUE)
avg(ev)
avg(ev)
plot(ev, annotate = TRUE)
library(shiny)
library(tidyr)
library(recommenderlab)
## Load Data
artists = read.table("Data/artists_gp4.dat",sep="\t",stringsAsFactors = F,comment.char = "",quote="",header = T)
user_artists = read.table("Data/user_artists_gp4.dat",sep="\t",header = T)
### Data Transformation
#Let's convert to wider format such that each row represent the listened count of a user.
user_artists_wide <- spread(user_artists,key=artistID,value=weight)
dim(user_artists_wide)
## Create character Id
artists$charid=paste0("I",artists$id)
userids=user_artists_wide$userID
user_artists_wide$IuserID = NULL
rownames(user_artists_wide) = paste0("U",userids)
colnames(user_artists_wide) = paste0("I",colnames(user_artists_wide))
user_artists_wide[1:6,1:10]
# Select Top 1000
visits_byitem=colSums(user_artists_wide[,-1],na.rm = T)
visits_1k = user_artists_wide[,order(visits_byitem,decreasing = T)[1:1000]]
# Select users who has listened to at least 10 artists
num_visits=apply(visits_1k,1,function(x) return(sum(!is.na(x))))
visits_1k = visits_1k[num_visits>10,]
dim(visits_1k)
# Data is centered and scaled
visits_1k=t(scale(t(visits_1k))[,])
# Convert visits_1k into a recommanderlab sparse matrix
visits_1k_rrm=as(as.matrix(visits_1k),"realRatingMatrix")
set.seed(100)
# The matrix is converted into a realRatingMatrix object which stores the data in sparse format
# (only non-NA values are stored explicitly; NA values are represented by a dot)
r <- visits_1k_rrm
# Understand the data better
as(r[1,], "list")
rowMeans(r[1,])
hist(getRatings(r), breaks=60)
hist(rowCounts(r), breaks=50)
hist(colMeans(r), breaks=20)
# The rating matrix can converted into a data.frame with user/item/rating tuples.
head(as(r, "data.frame"))
################################################################################
# here we have all the different methods
recommenderRegistry$get_entries(dataType = "realRatingMatrix")
# We create recommenders which generates recommendations of songs
p_rr <- Recommender(r[1:700], method = "POPULAR")
ib_rr <- Recommender(r[1:700], method = "IBCF")
# Recommendations in the form of an object of class TopNList
# We create top-5 recommendation lists for 88 users who were not used to learn the model.
recom <- predict(p_rr, r[700:788], n=5)
recom
recom@items
recom@ratings
# The result contains two ordered top-N recommendation lists, one for each user.
# The recommended items can be inspected as a list
Myrecommendations<-as(recom, "list")
for (i in 1:5){
print(Myrecommendations[i])
print(artists$name[artists$charid %in% Myrecommendations[[i]]])
}
# The best 3 recommendations for each list using bestN().
recom3 <- bestN(recom, n = 3)
recom3
Myrecommendations3<-as(recom3, "list")
for (i in 1:3){
print(Myrecommendations3[i])
print(artists$name[artists$charid %in% Myrecommendations3[[i]]])
}
### Evaluation of predicted ratings
# Evaluation of a top-N recommender algorithm
set.seed(100)
e <- evaluationScheme(r, method="cross", k=4, given=10, goodRating=1.2)
train=getData(e, "train")
test=getData(e, "known")
ub_r <- Recommender(train, method="UBCF", param=list(nn=50, normalize="center"))
p_r <- Recommender(train, method="POPULAR")
ib_r <- Recommender(train, method="IBCF", param=list(k=50, method="cosine", normalize="center"))
svd_r <- Recommender(train, method="SVD")
# Compute predicted ratings for the known part of the test data  (10 items for each
# user) using the algorithms.
p_p <- predict(p_r, test, type="ratings")
ib_p <- predict(ib_r, test, type="ratings")
ub_p <- predict(ub_r, test, type="ratings")
svd_p <- predict(svd_r, test, type = "ratings")
# Create a hybrid recommender
hybrid_r <- HybridRecommender(
Recommender(train, method = "POPULAR"),
Recommender(train, method = "IBCF"),
Recommender(train, method = "UBCF"),
weights = c(0.65, 0.25, 0.10)
)
hybrid_p <- predict(hybrid_r, test, type = "ratings")
# Hybrid + cascade aproach of Popular, IBCF and UBCF + UBCF
hcas <- (0.35 * as(p_p, "matrix") + 0.35 * as(ib_p, "matrix") + 0.3 * as(ub_p, "matrix") )
hcas_rrm <- as(hcas, "realRatingMatrix")
hcas_r <- Recommender(hcas_rrm, method="UBCF", param=list(nn=50))
hcas_p <- predict(hcas_r, test, type="ratings")
# Evaluating cascade UBCF and then IBCF on top of the UBCF
cascade_r_rrm <- as(as(p_p, "matrix"), "realRatingMatrix")
cascade_r <- Recommender(cascade_r_rrm, method="UBCF",param=list(nn=50, normalize="center"))
cascade_p <- predict(cascade_r, test, type="ratings")
# check best recommender errors
error <- rbind(
POPULAR = calcPredictionAccuracy(p_p, getData(e, "unknown")),
ib = calcPredictionAccuracy(ib_p, getData(e, "unknown")),
ub = calcPredictionAccuracy(ub_p, getData(e, "unknown")),
svd = calcPredictionAccuracy(svd_p, getData(e, "unknown")),
hybrid = calcPredictionAccuracy(hybrid_p, getData(e, "unknown")),
hcas = calcPredictionAccuracy(hcas_p, getData(e, "unknown")),
CASCADE = calcPredictionAccuracy(cascade_p, getData(e, "unknown"))
)
error
algorithms <- list(
POPULAR = list(name = "POPULAR", param = NULL),
IBCF = list(name = "IBCF", param = NULL),
UBCF = list(name = "UBCF", param = NULL),
SVD = list(name = "SVD", param = NULL),
HYBRID = list(name = "HYBRID", param = list(
recommenders = list(
POPULAR = list(name = "POPULAR", param = NULL),
IBCF = list(name = "IBCF", param = NULL),
UBCF = list(name = "UBCF", param = NULL)
),
weights = c(0.35, 0.35, 0.3)
))
)
error
ev <- evaluate(e, algorithms, n = c(1, 3, 5, 10, 15, 20))
getConfusionMatrix(ev)[[1]]
getConfusionMatrix(ev)
plot(ev, annotate = TRUE)
plot(ev, annotate = TRUE)
plot(ev, "prec/rec", annotate=TRUE)
getConfusionMatrix(ev)[[1]]
